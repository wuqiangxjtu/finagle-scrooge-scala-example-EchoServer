/**
 * Generated by Scrooge
 *   version: ?
 *   rev: ?
 *   built at: ?
 */
package mwding.simpleecho

import com.twitter.scrooge.{
  TFieldBlob, ThriftService, ThriftStruct, ThriftStructCodec, ThriftStructCodec3, ThriftUtil}
import java.nio.ByteBuffer
import java.util.Arrays
import org.apache.thrift.protocol._
import org.apache.thrift.transport.TTransport
import org.apache.thrift.TApplicationException
import org.apache.thrift.transport.TMemoryBuffer
import scala.collection.immutable.{Map => immutable$Map}
import scala.collection.mutable.{
  ArrayBuffer => mutable$ArrayBuffer, Buffer => mutable$Buffer,
  HashMap => mutable$HashMap, HashSet => mutable$HashSet}
import scala.collection.{Map, Set}


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"), date = "2013-11-17T16:29:20.203-0500")
trait EchoService[+MM[_]] extends ThriftService {
  
  def echo(req: SimpleRequest): MM[SimpleResponse]
}


object EchoService {
  
  object echo$args extends ThriftStructCodec3[echo$args] {
    val Struct = new TStruct("echo_args")
    val ReqField = new TField("req", TType.STRUCT, 1)
    val ReqFieldManifest = implicitly[Manifest[SimpleRequest]]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: echo$args) {
    }
  
    override def encode(_item: echo$args, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): echo$args = Immutable.decode(_iprot)
  
    def apply(
      req: SimpleRequest
    ): echo$args = new Immutable(
      req
    )
  
    def unapply(_item: echo$args): Option[SimpleRequest] = Some(_item.req)
  
  
    private def readReqValue(_iprot: TProtocol): SimpleRequest = {
      SimpleRequest.decode(_iprot)
    }
  
    private def writeReqField(req_item: SimpleRequest, _oprot: TProtocol) {
      _oprot.writeFieldBegin(ReqField)
      writeReqValue(req_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeReqValue(req_item: SimpleRequest, _oprot: TProtocol) {
      req_item.write(_oprot)
    }
  
  
    private class Decoder(_iprot: TProtocol) {
      private[this] var req: SimpleRequest = null
      private[this] var _got_req = false
      private[this] var _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
  
      private def readReq(_field: TField) {
        _field.`type` match {
          case TType.STRUCT => {
            req = readReqValue(_iprot)
            _got_req = true
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
      }
  
      def read(): echo$args = {
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => readReq(_field)
              case _ =>
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        result()
      }
  
      def result(): echo$args = {
        new Immutable(
          req,
          _passthroughFields.result()
        )
      }
    }
  
    object Immutable extends ThriftStructCodec3[echo$args] {
      override def encode(_item: echo$args, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): echo$args = new Decoder(_iprot).read()
    }
  
    /**
     * The default read-only implementation of echo$args.  You typically should not need to
     * directly reference this class; instead, use the echo$args.apply method to construct
     * new instances.
     */
    class Immutable(
      val req: SimpleRequest,
      override val _passthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty
    ) extends echo$args
  
  }
  
  trait echo$args extends ThriftStruct
    with Product1[SimpleRequest]
    with java.io.Serializable
  {
    import echo$args._
  
    def req: SimpleRequest
  
    def _1 = req
  
    def _passthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty
  
    /**
     * Gets a field value encoded as a binary blob using TCompactProtocol.  If the specified field
     * is present in the passthrough map, that value is returend.  Otherwise, if the specified field
     * is known and not optional and set to None, then the field is serialized and returned.
     */
    def getFieldBlob(_fieldId: Short): Option[TFieldBlob] = {
      lazy val _buff = new TMemoryBuffer(32)
      lazy val _oprot = new TCompactProtocol(_buff)
      _passthroughFields.get(_fieldId) orElse {
        val _fieldOpt: Option[TField] =
          _fieldId match {
            case 1 =>
              if (req ne null) {
                writeReqValue(req, _oprot)
                Some(echo$args.ReqField)
              } else {
                None
              }
            case _ => None
          }
        _fieldOpt match {
          case Some(_field) =>
            val _data = Arrays.copyOfRange(_buff.getArray, 0, _buff.length)
            Some(TFieldBlob(_field, _data))
          case None =>
            None
        }
      }
    }
  
    /**
     * Collects TCompactProtocol-encoded field values according to `getFieldBlob` into a map.
     */
    def getFieldBlobs(ids: TraversableOnce[Short]): immutable$Map[Short, TFieldBlob] =
      (ids flatMap { id => getFieldBlob(id) map { id -> _ } }).toMap
  
    /**
     * Sets a field using a TCompactProtocol-encoded binary blob.  If the field is a known
     * field, the blob is decoded and the field is set to the decoded value.  If the field
     * is unknown and passthrough fields are enabled, then the blob will be stored in
     * _passthroughFields.
     */
    def setField(_blob: TFieldBlob): echo$args = {
      var req: SimpleRequest = this.req
      var _passthroughFields = this._passthroughFields
      _blob.id match {
        case 1 =>
          req = readReqValue(_blob.read)
        case _ => _passthroughFields += (_blob.id -> _blob)
      }
      new Immutable(
        req,
        _passthroughFields
      )
    }
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): echo$args = {
      var req: SimpleRequest = this.req
  
      _fieldId match {
        case 1 =>
          req = null
        case _ =>
      }
      new Immutable(
        req,
        _passthroughFields - _fieldId
      )
    }
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetReq: echo$args = unsetField(1)
  
  
    override def write(_oprot: TProtocol) {
      echo$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (req ne null) writeReqField(req, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      req: SimpleRequest = this.req,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): echo$args =
      new Immutable(
        req,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[echo$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[echo$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => req
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "echo$args"
  }
  
  object echo$result extends ThriftStructCodec3[echo$result] {
    val Struct = new TStruct("echo_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val SuccessFieldManifest = implicitly[Manifest[SimpleResponse]]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: echo$result) {
    }
  
    override def encode(_item: echo$result, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): echo$result = Immutable.decode(_iprot)
  
    def apply(
      success: Option[SimpleResponse] = None
    ): echo$result = new Immutable(
      success
    )
  
    def unapply(_item: echo$result): Option[Option[SimpleResponse]] = Some(_item.success)
  
  
    private def readSuccessValue(_iprot: TProtocol): SimpleResponse = {
      SimpleResponse.decode(_iprot)
    }
  
    private def writeSuccessField(success_item: SimpleResponse, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: SimpleResponse, _oprot: TProtocol) {
      success_item.write(_oprot)
    }
  
  
    private class Decoder(_iprot: TProtocol) {
      private[this] var success: SimpleResponse = null
      private[this] var _got_success = false
      private[this] var _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
  
      private def readSuccess(_field: TField) {
        _field.`type` match {
          case TType.STRUCT => {
            success = readSuccessValue(_iprot)
            _got_success = true
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
      }
  
      def read(): echo$result = {
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => readSuccess(_field)
              case _ =>
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        result()
      }
  
      def result(): echo$result = {
        new Immutable(
          if (_got_success) Some(success) else None,
          _passthroughFields.result()
        )
      }
    }
  
    object Immutable extends ThriftStructCodec3[echo$result] {
      override def encode(_item: echo$result, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): echo$result = new Decoder(_iprot).read()
    }
  
    /**
     * The default read-only implementation of echo$result.  You typically should not need to
     * directly reference this class; instead, use the echo$result.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[SimpleResponse] = None,
      override val _passthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty
    ) extends echo$result
  
  }
  
  trait echo$result extends ThriftStruct
    with Product1[Option[SimpleResponse]]
    with java.io.Serializable
  {
    import echo$result._
  
    def success: Option[SimpleResponse]
  
    def _1 = success
  
    def _passthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty
  
    /**
     * Gets a field value encoded as a binary blob using TCompactProtocol.  If the specified field
     * is present in the passthrough map, that value is returend.  Otherwise, if the specified field
     * is known and not optional and set to None, then the field is serialized and returned.
     */
    def getFieldBlob(_fieldId: Short): Option[TFieldBlob] = {
      lazy val _buff = new TMemoryBuffer(32)
      lazy val _oprot = new TCompactProtocol(_buff)
      _passthroughFields.get(_fieldId) orElse {
        val _fieldOpt: Option[TField] =
          _fieldId match {
            case 0 =>
              if (success.isDefined) {
                writeSuccessValue(success.get, _oprot)
                Some(echo$result.SuccessField)
              } else {
                None
              }
            case _ => None
          }
        _fieldOpt match {
          case Some(_field) =>
            val _data = Arrays.copyOfRange(_buff.getArray, 0, _buff.length)
            Some(TFieldBlob(_field, _data))
          case None =>
            None
        }
      }
    }
  
    /**
     * Collects TCompactProtocol-encoded field values according to `getFieldBlob` into a map.
     */
    def getFieldBlobs(ids: TraversableOnce[Short]): immutable$Map[Short, TFieldBlob] =
      (ids flatMap { id => getFieldBlob(id) map { id -> _ } }).toMap
  
    /**
     * Sets a field using a TCompactProtocol-encoded binary blob.  If the field is a known
     * field, the blob is decoded and the field is set to the decoded value.  If the field
     * is unknown and passthrough fields are enabled, then the blob will be stored in
     * _passthroughFields.
     */
    def setField(_blob: TFieldBlob): echo$result = {
      var success: Option[SimpleResponse] = this.success
      var _passthroughFields = this._passthroughFields
      _blob.id match {
        case 0 =>
          success = Some(readSuccessValue(_blob.read))
        case _ => _passthroughFields += (_blob.id -> _blob)
      }
      new Immutable(
        success,
        _passthroughFields
      )
    }
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): echo$result = {
      var success: Option[SimpleResponse] = this.success
  
      _fieldId match {
        case 0 =>
          success = None
        case _ =>
      }
      new Immutable(
        success,
        _passthroughFields - _fieldId
      )
    }
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetSuccess: echo$result = unsetField(0)
  
  
    override def write(_oprot: TProtocol) {
      echo$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[SimpleResponse] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): echo$result =
      new Immutable(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[echo$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[echo$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "echo$result"
  }

  import com.twitter.util.Future

  trait FutureIface extends  EchoService[Future] {
    
    def echo(req: SimpleRequest): Future[SimpleResponse]
  }

  class FinagledClient(
      service: com.twitter.finagle.Service[com.twitter.finagle.thrift.ThriftClientRequest, Array[Byte]],
      protocolFactory: TProtocolFactory = new TBinaryProtocol.Factory,
      serviceName: String = "",
      stats: com.twitter.finagle.stats.StatsReceiver = com.twitter.finagle.stats.NullStatsReceiver)
    extends EchoService$FinagleClient(
      service,
      protocolFactory,
      serviceName,
      stats)
    with FutureIface

  class FinagledService(
      iface: FutureIface,
      protocolFactory: TProtocolFactory)
    extends EchoService$FinagleService(
      iface,
      protocolFactory)
}